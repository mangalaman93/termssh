#!/bin/bash 

##############################################################################
#    Bash script written by Vahid Hedayati September 2012
#    Download termssh
#    cp termssh /usr/local/bin/ && chmod 755 /usr/local/bin/termssh
##############################################################################
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
##############################################################################
#  Script to manage/automate terminator layouts / connections
#  You can either connect to servers via a text file -f {filename}
#  or via autodiscovery -a prod tamjo app1 app2 .. app6   
#  The auto discover segment will need adjustment and may need to be modified 
#  to work  with the server labelling within your organisation
#
#  -fs fullscreen mode if not set to 1 below
#  -r  remove layout i.e. current layout being generated - refresh its config
#  -w 2/4/8 windows can be defined to open windows per tab.
# - c to connect -d to remove existing layout
##############################################################################



#############################################################################################

###############################
# Amount of windows to open up with terminator
# can be set to 2,4 or 8 
DEFAULT_WINDOWS=4


###############################
# NEW Feature - now auto groups servers 
# With -x 1-10 a user can connect to multiple servers multiple times and have each instance 1 of each server 
# in a specific group and so forth - its automatic
# even with 1 connection per server it will group tomcats in one group and apaches in another ;)
# if enabled and servers match grouping conventions then groups defined by set_grouping function
# if set to 0 -g required to enable grouping

AUTO_GROUPING_ENABLED=0;


###############################
# Connection amount per server
# Another addition sometimes I wish to connect to same servers multiple times
# maybe one to watch output whilst issuing command to another
# -x 1-10 default is one time and with above grouping each apache will be in apache-1 apache-2
# so londonapa01gw and londonapa01bw with -x 2 will result in 
# first connection londonapa01gw in group apache-1
# second connection londonapa01gw in group apache-2
# repeated with 2nd server so what ever you put in group apache-1 will be repeatd in instance of both servers

DEFAULT_CONNECTIONS=1;



###############################
# Full screen mode - toggle between 0/1 
# if set to 0 then -fs is required as part of arguments to force new connections to full screen
# mode. If an existing layout -r -fs is required as part of argument to rediscover connection 
# and set it as full screen

FULL_SCREEN_MODE=0;



###############################
# If you are trying get auto discovery to work - more verbosity is given and connections are 
# converted to local /bin/bash  command on local machine executing this script

DEBUG=0;


#############################################################################################
# Terminator configuration dir and file as well as temp storage file for auto discovery

terminator_config_folder="$HOME/.config/terminator"
terminator_config_file="$terminator_config_folder/config"
FILE="/tmp/hosts.collect";

#############################################################################################

############################################################################################
# Environment variables  for auto discovery
# Initial script built to put for example:
# an input of: -a prod at ce cex

####################################
# $prod_location + $apache_convention + $prod_env + [a-z] + {server_types last input values}
# londons +{apa/tct} + 01 + {a-z} + ce
# londons +{apa/tct} + 01 + a + cex
# so it would find | londonsapa01acex -to- londonsapa01zcex  |  londonstct01acex -to-  londonstct01zcex
# as well as | londonsapa01ace -to- londonsapa01zce    |  londonstct01ace -to-  londonstct01zce
####################################

# Auto discovery configuration for alphabet if your servers use alphabet for naming convention
# use / trim the alpha-array to suite you - less alphabet = less time to launch
# This is used in conjunction with a few functions but most importantly check_method() - 
# If you fine tuned auto discovery to match server naming convention 
# and find it takes too londong  replace the query method below
# trimming alpharray to optimum server farm size will help

alpharray=(a b c d e f g h i j k l m n o p q r s t u v w x y z )

# comment above and uncomment below for a-b server matches
#alpharray=( a b )

 
##
prod_location="londons";
prod_env="01";

stage_location="londong";
stage_env="04";

uat_location="londong";
uat_env="02";

##
apache_convention="apa";
tomcat_convention="tct";
mysql_convention="mql";
jboss_convention="jbs";
oracle_convention="ora";

# group conventions - maps with above conventiona
apache_group="apache";
tomcat_group="tomcat";
mysql_group="mysql";
jboss_group="jboss";
oracle_group="oracle";

############################################################################################

############################################################################################
# This is method to auto discover - you can change method to improve speed of discovery
# querymethod choices are configured in function check_method : 
# you can change to :
# host nslookup dig shortdig netcat nc ping

querymethod="nc";
#############################################################################################

#############################################################################################
# DEFAULT GLOBAL CONFIGURATION FOR TERMINATOR CONFIG FILE GENERATION
DF="[global_config]\n  enabled_plugins = LaunchpadCodeURLHandler, APTURLHandler,";
DF="$DF LaunchpadBugURLHandler\n [keybindings]\n[profiles]\n"
DF="$DF  [[default]]\n    scrollback_infinite = True\n    ";
DF="$DF split_to_group = true\n    foreground_color = \"#ffffff\""
DEFAULT_CONFIG=$DF;
#############################################################################################

#############################################################################################
#####  END OF VARIABLES AND CONFIGURATION - BELOW IS THE MAIN CODE USED FOR TERMSSH   #######
#############################################################################################




#############################################################################################
# This  validate servers is the core of auto discovery - 
# disable check method line 137 to not try to check server - renable once it works
# use -l and followed by what you would give for -a to list or enable debug mode so it lists
# all hosts

conapps="";
function validate_servers() {
   > $FILE
    serverarray=( $server_types )
    ## For 6 types of service inputs
    for index in  0 1 2 3 4 5   
    do
	#Set currapp as array value 
	currapp=${apparray[index]}
	#echo "___$currapp"
	
	if [ "$currapp" != "" ]; then 
	     conapps=$conapps"_"$currapp;
	    ## Does currentapplication has a value?
	    ## Work through env array from above
	    for serverindex in  0 1 2 3 4
	    do
		#set currenv as currentenv value
                currserver=${serverarray[serverindex]}
		#echo $currserver
		## if it has a value
                if [ "$currserver" != "" ]; then 
		    # a-z go through the servers
		    for xx in  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
		    do
			x=${alpharray[xx]}
			if [ "$x" != "" ];then
			    server="$host_start$currserver$host_env$x$currapp"
			    if [ $DEBUG -ge 1 ]; then
				echo  "Current server: $server "
			    fi
			    check_method;
			fi
		    done
		fi
	     done
	 fi
    done
    if [ $DEBUG -ge 1 ]; then
	echo  "_________________________________________________"
	echo  "CONNECTIONS WILL BE MADE TO:"
	echo  "_________________________________________________"
	cat $FILE
   fi
}
#############################################################################################


#############################################################################################
#SERVER CHECK METHODS
function check_method()  {
      #> $FILE
      if [ "$querymethod" == "nc" ]; then 
	  nc -v  -w 1 $server -z 22 2>&1|grep succeeded > /dev/null	
      elif [ "$querymethod" == "netcat" ]; then 
	  netcat -v  -w 1 $server -z 22 2>&1|grep succeeded >/dev/null
      elif [ "$querymethod" == "host" ]; then 
	  host $server | awk '/^[[:alnum:].-]+ has address/ { print $4 ; exit }' 2>&1|grep [1-9] > /dev/null
      elif [ "$querymethod" == "nslookup" ]; then 
	nslookup $server | awk '/^Address: / { print $2 ; exit }'  2>&1|grep [1-9] > /dev/null
      elif [ "$querymethod" == "dig" ]; then 
	dig  $server | awk '/^;; ANSWER SECTION:$/ { getline ; print $5 ; exit }'  2>&1|grep [1-9] > /dev/null
      elif [ "$querymethod" == "shortdig" ]; then 
	dig +short $server | awk 'NR > 1 { exit } ; 1 2>&1|grep [1-9] > /dev/null'
      elif [ "$querymethod" == "ping" ]; then 
	ping -c1 $server 2>&1|grep bytes > /dev/null
      else
	nc -v  -w 1 $server -z 22 2>&1|grep succeeded > /dev/null	
      fi
	
      if [ $? = 0 ]; then
         echo $server >> $FILE
      fi
}
#############################################################################################



#############################################################################################
# -a [first val] prod or stage or anything else
# sets envionmental values for first value of -a option
function set_environment() {
  if [ "$environment" == "prod" ]; then
      host_env=$prod_env; host_start=$prod_location;
  elif [ "$environment" == "stage" ]; then
      host_env=$stage_env; host_start=$stage_location;
  else
      host_env=$uat_env; host_start=$uat_location;
  fi
}
#############################################################################################


#############################################################################################
# -a [second val] tamjo 
# where the initials tamjo is converted to conventions of tomcat,apache,jboss,oracle & mysql
function set_apptype() {
  local input=$apptype;
  server_types="";
  if [[ $input =~ a ]]; then
        server_types=$server_types" $apache_convention "
  fi
  if [[ $input =~ t ]]; then
        server_types=$server_types" $tomcat_convention "
  fi
  if [[ $input =~ j ]]; then
        server_types=$server_types" $jboss_convention "
  fi
  if [[ $input =~ m ]]; then
        server_types=$server_types" $mysql_convention "
  fi
  if [[ $input =~ o ]]; then
        server_types=$server_types" $oracle_convention "
  fi
}
#############################################################################################


#############################################################################################
# AUTO_GROUPING_ENABLED if set to 1 uses above convention name configuration to check current
# server being processed and if it matches then group it is placed in specific group
groupname="";
function set_grouping() {
  local input=$servers;
    if [ $AUTO_GROUPING_ENABLED -ge 1 ];then
      if [[ $input =~ $apache_convention ]]; then
	  groupname=$apache_group
      fi
      if [[ $input =~ $tomcat_convention ]]; then
	  groupname=$tomcat_group
      fi
      if [[ $input =~ $jboss_convention ]]; then
	  groupname=$jboss_group
      fi
      if [[ $input =~ $mysql_convention ]]; then
	  groupname=$mysql_group
      fi
      if [[ $input =~ $oracle_convention ]]; then
	  groupname=$oracle_group
      fi
    fi
}
#############################################################################################

#############################################################################################
# Screen resolution 
function set_resolution() { 
    horizontal=`xdpyinfo  | grep 'dimensions:'|awk '{print $2}'|awk -F"x" '{print $1}'`
    vertical=`xdpyinfo  | grep 'dimensions:'|awk '{print $2}'|awk -F"x" '{print $2}'`
    unknown=0;
    if ((horizontal)) 2>/dev/null; then
      horizontal=$((horizontal))
      vertical=$((vertical))
    else
      horizontal=1024
      vertical=768
      unknown=1;
    fi
    if [ $unknown -eq 0 ] && [ $FULL_SCREEN_MODE -ne 1 ]; then
      horizontal=`expr $horizontal / 2`
      vertical=`expr $vertical / 2`
    fi
}
#############################################################################################

#############################################################################################
# This finds layout name being processed and using ed removes block of config
function del_entry() { 
   grep "$layout" $terminator_config_file > /dev/null
    if [ $? = 0 ]; then
    
    delids=`egrep -n "( \\\[\\\[[a-z]|^\\\[\\\[[a-z])" $HOME/.config/terminator/config|grep -v default|grep -A1 $layout|awk -F":" '{print $1}'|tr "\n" " "`
    delarray=( $delids )
    val1=${delarray[0]}
    val2=${delarray[1]}
    if [ "$val2"  == "" ]; then 
	val2=`wc -l $terminator_config_file|awk '{print $1}'`
    else
	((val2--))
   fi
   doit=$val1","$val2"d"
   ed -s $terminator_config_file << EOF
$doit
.
w
q
EOF
    colourit red "`echo $LOGNAME` you have issued -r : Layout  $layout has now been removed !!"
    colourit blue "Will recreate $layout "
  else
      colourit red "could not find $layout in $config - -r ignored"
  fi

}
#############################################################################################

#############################################################################################
# depreceated was used to confirm if they wanted to refresh config which is overridden by -r
function check_layout() { 
      grep "$layout" $terminator_config_file > /dev/null
      if [ $? = 0 ]; then
	colourit red "Profile : $layout exists !!!!"
	colourit blue "Would you like to remove layout (y/n)?"
	read choice;
	if [ "$choice" == "y" ];then
	    colourit blue "Deleting Entry for $layout from $terminator_config_file"
	    del_entry; 
	fi
      fi
}		
#############################################################################################

#############################################################################################
# function used to confirm if layout is new or has already been added
LAYOUT_FOUND=0;
function find_layout() { 
      grep "$layout" $terminator_config_file > /dev/null
      if [ $? = 0 ]; then
	  LAYOUT_FOUND=1;
      fi
}		
#############################################################################################

#############################################################################################
# -c standalone option to manage existing layout connection 
# lists layouts numerically selectable
function connect_existing_layout() { 
	colourit blue  "You are about to connect to an existing terminator layout, please type in the number to remove the layout"	
	PS3='Choose your terminator connection: '
	OLDIFS=$IFS
	IFS=$'\n'
	layouts=`egrep "( \\\[\\\[[a-z]|^\\\[\\\[[a-z])" $HOME/.config/terminator/config|grep -v default|tr -d "["|tr -d "]"`
	echo
	  select layout  in $layouts
	  do
	    #IFS=$OLDIFS
	    layout=${layout//[[:space:]]}
	    echo
	    echo "connecting to \"$layout\""
	    terminator -l "$layout"&
	    break
	  done
	exit
}
#############################################################################################

#############################################################################################
# -d standalone option to manage existing layout removal 
# lists layouts numerically selectable
function delete_existing_layout() { 

	colourit red "WARNING ! You are about to remove a terminator layout, please type in the number to remove the layout"	
	PS3="Choose your terminator connection to remove:"
	OLDIFS=$IFS
	IFS=$'\n'
	layouts=`egrep "( \\\[\\\[[a-z]|^\\\[\\\[[a-z])" $HOME/.config/terminator/config|grep -v default|tr -d "["|tr -d "]"`
	echo
	  select layout  in $layouts
	  do
	    #IFS=$OLDIFS
	    layout=${layout//[[:space:]]}
	    echo
	    colourit red "Deleting $layout"
	    del_entry;
	    break
	  done
	exit
}
#############################################################################################

#############################################################################################
# -s s1,s2,s3,s4 
# this reads in a list of comma seperated servers as input and adds them to temp file to be
# processed by set_terminator like -f {file} option
function read_cli_servers() { 
>$FILE
OLDIFS=$IFS;
IFS=" ,"
i=0
for val in ${servernames}
do
  i=$((++i))
  eval var${i}="${val}"
done
IFS=$OLDIFS;
for ((j=1;j<=i;++j))
do
  name="var${j}"
  echo ${!name} >> $FILE
done


}

function set_windows() { 
   if ((WINDOWS)) 2>/dev/null; then
      WINDOWS=$((WINDOWS))
    else
      WINDOWS=$DEFAULT_WINDOWS;
    fi	
}
#############################################################################################



#############################################################################################
# process config ensures terminator config folder file exists, if file has layouts then 
# it adds this layout so londong as no other layouts have the same name, if same name found it 
# will launch it if current config appears incomplete it will back up and replace it with 
# new global config and new layout then launch terminator
#############################################################################################
CONFIG_LAYOUT="";
function process_config() { 

  if [ ! -d $terminator_config_folder ]; then
      echo "creating $terminator_config_folder"
      mkdir -p $terminator_config_folder
  fi
  if [ ! -f $terminator_config_file ]; then
      echo "not found $terminator_config_file"
      touch $terminator_config_file
      echo -e "$DEFAULT_CONFIG" > $terminator_config_file
      echo -e "$CONFIG_LAYOUT" >> $terminator_config_file
  else
	grep "\[layouts\]" $terminator_config_file > /dev/null
	if [ $? = 0 ]; then
	   grep "$layout" $terminator_config_file > /dev/null
	   if [ $? = 0 ]; then
		 colourit blue "Loading $layout"
	    else
	      colourit blue "Layout by the name of: $layout not found in $terminator_config_file"
	      colourit blue "Will push $layout to your configuration and attempt to load it"
	      in1="[layouts]"
	      out1=`echo -e $CONFIG_LAYOUT`;
	      in=$in1 out=$out1 perl -pi.nk -e 's/\Q$ENV{"in"}/$ENV{"out"}/g'  $terminator_config_file 
	    fi
	 else
	    newfile=$terminator_config_file.$$
	    cp $terminator_config_file $newfile
	    echo "old config backed up as $newfile"
	    grep "\[global_config\]" $terminator_config_file > /dev/null
	    if [ $? = 0 ]; then
		    echo -e "[layouts]\n" >> $terminator_config_file
		    echo -e "$CONFIG_LAYOUT" >> $terminator_config_file
	    else
		    echo -e "$DEFAULT_CONFIG" > $terminator_config_file
		    echo -e "$CONFIG_LAYOUT" >> $terminator_config_file
	    fi
	 fi
   fi
}
# End of process_config
#############################################################################################



#############################################################################################
#-x numeric value 
# so for reach server how many times to open a connection 
# this function repeats server reconnections

function check_reconnection() { 
  local value=$reconnect;
    if [ "$value" == "" ]; then
	value=$DEFAULT_CONNECTIONS;
    fi
	  >$FILE.tmp
	if ((value)) 2>/dev/null; then
	  value=$((value));
	  j=0;
	  for ((i=0; i < $value; i++)) 
	   do
		((j++))
		for servers in `cat $FILE`
		do
		   set_grouping
		    if [  "$groupname" !=  "" ];then
			if [ $DEBUG -ge 1 ];then
			  echo "FOUND $groupname"
			  echo $servers"|"$groupname"-"$j   $FILE.tmp
			fi
			echo $servers"|"$groupname"-"$j >> $FILE.tmp
		    else
			if [ $DEBUG -ge 1 ];then
			   echo "NOT FOUND $groupname"
			   echo $servers $FILE.tmp
			fi
			echo $servers >> $FILE.tmp
		    fi
		done
	    done
	    FILE=$FILE.tmp
	   fi    
}

#############################################################################################



#############################################################################################
# oh this is a monster
# this big boy does all the terminator layout stuff and works in all forms of user input 
#  i.e. -a -f -s 

function set_terminator() { 
set_resolution;
	set_windows;
	
	if [ "$USERCHOICE" == "F" ];then
	  layabout=`echo $FILE |awk -F"/" '{print $NF}'|awk -F"." '{print $1}'`
	  layout=$layabout"_"$WINDOWS
	elif [ "$USERCHOICE" == "A" ]; then
	  layout=$environment"_"$apptype"_"$conapps"_"$WINDOWS
	elif [ "$USERCHOICE" == "I" ]; then
	  layout=$servernames"_"$WINDOWS	
	else
	  layout="layout_"$WINDOWS
	fi
	if [ $DEBUG -ge 1 ];then
		layout="test_"$layout
	fi

	#changed from asking to giving -r option which sets auto removal
	#check_layout;
	if [ $REMOVE_LAYOUT -ge 1 ] && [ "$layout" != "" ];then
	  del_entry
	fi
	
	find_layout;
	if [ $LAYOUT_FOUND -le 0 ] ;then
	  
	    nm="";
	    appnames=""
	    check_reconnection
	    for names in `cat $FILE`
	    do
		nm=$nm" "$names
	        appnames=$appnames"_"$names
	    done
	    serverarray=( $nm )
	    servercount=`wc -l $FILE|awk '{print $1}'`
	    if [ $WINDOWS -gt $servercount ]; then
		WINDOWS=$servercount;
	    fi

	    if [ $servercount -le 1 ]; then
		tabs=0;
		tabamount=0;
	    else
		tabs=`expr $servercount / $WINDOWS`
		tabsamount=`echo "scale=1; $servercount / $WINDOWS"|bc|awk -F"." '{print $2}'`
	    fi
	    if [ "$tabsamount" != "0" ] && [ "$tabsamount" != "" ];then
                (( tabs++ ))
	    fi
	    tabtotal=$tabs
	
	    
	    labels="";
	    pane="HPaned";
	    z=0;
	    currentid=0;
	    previousid=0;
	    colourit green  "Total servers $servercount  | Tabs required $tabtotal |   LAYOUT= $layout $0 -c to reconnect"
	    for ((tabsi=0; tabsi < $tabtotal; tabsi++))
	    do
		if [ "$labels" == "" ];then
		    #labels="tab_$tabsi";
		    labels="None";
		else
		    #labels=$labels", tab_$tabsi"
		    labels=$labels", None";
		fi
	    done
	    CONFIG_LAYOUT=$CONFIG_LAYOUT" [layouts]\n  [[$layout]]\n   [[[child0]]]\n   position = 0:0\n   type = Window\n   order = 0\n   parent = \"\"\n   size = $horizontal,$vertical\n";
	    previousid=$currentid;
	    previouschildid=$currentid
	    previouschildid1=$currentid
	    ((currentid++))
	    
	    addid=0;
	    if [ $tabtotal -gt 1 ]; then
		CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[child$currentid]]]\n   labels = $labels\n   type = Notebook\n   order = 0\n   parent = child$previouschildid\n";
		addid=1;
	    else
		if [ $servercount -gt 2 ]; then
		  CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[child$currentid]]]\n   position = 100\n   type = VPaned\n   order = 0\n   parent = child$previouschildid\n";
		  addid=1;
		fi
	    fi
	    if [ "$addid" == "1" ]; then
	      previouschildid1=$currentid
	      previoustabid=$currentid
	      previousid=$currentid;
	      ((currentid++))
	    fi;

	    currentserversize=$servercount;
	    if  [[ $WINDOWS =~ 1 ]] || [[ $WINDOWS =~ 2 ]]; then 
		splitsize=1;
	    else
		splitsize=`expr $WINDOWS / 2`
		splitsamount=`echo "scale=1;  $WINDOWS / 2 "|bc|awk -F"." '{print $2}'`
		if [ "$splitsamount" != "0" ] && [ "$splitsamount" != "" ];then
		    (( splitsize++ ))
		fi
	    fi
	    a=0; b=0; bb=0;
	    for ((tabsi=0; tabsi < $tabtotal; tabsi++))
	    do
		((b++))
		((bb++))
		((a++))
		ab=0;position=0;cval=0;
		position=`expr $horizontal / 2`
		if   [ $b -ge 2  ]; then
		    ab=1;  b=0;  
		fi 
		if [ $tabsi -ge 1 ]; then
		    cval=`expr $a - 1`
		fi
		if [ $tabtotal -gt 1 ]; then
		    CONFIG_LAYOUT=$CONFIG_LAYOUT"   [[[child$currentid]]]\n   position = $position\n   type = HPaned\n   order = $cval\n   parent = child$previouschildid1\n";
		    previoustabid=$currentid
		    previousid=$currentid;
		    previouschildid2=$currentid
		    ((currentid++))  
		else
		    previoustabid=$currentid
		    previousid=$currentid;
		    previouschildid2=$currentid
		fi

		#  winpos=`expr $position / 2`
		winpos="";
		gg=0 lastorder=0;
		for ((o=0; o < $splitsize; o++))
		do
		    ((bb++))
		    ((gg++))
		    if   [ $bb -ge 2  ]; then
			if [ $tabtotal -gt 1 ]; then
			    pane="VPaned";
			else
			    pane="HPaned"
			fi
			bb=0;
		    else
			if [ $tabtotal -gt 1 ]; then
			    pane="VPaned";
			else
			    pane="HPaned"
			fi
		    fi

		    if [ $splitsize -gt 2 ]; then      
			if [ $gg -ge 2 ]; then 
			    gg=0;
			    create_child2;
			    create_terminals;
			else
			    childbefore=$currentid;
			    create_child;
			    create_child2;
			    create_terminals;
			fi
		    else
			if  [ $tabtotal -gt 1 ] && [ $WINDOWS -gt 2 ] || [ $tabtotal -eq 1 ] && [ $WINDOWS -ge 2 ] ;then
			    create_child;
			    create_terminals;
			else
			    if  [ $tabtotal -gt 1 ];then 
				previousid=$currentid;
				((previousid--))
				terminal_id=$currentid;
				create_terminals;
			    else
				((previousid--))
				create_terminals;
			    fi
			fi
		    fi
	      done
	  done
	fi
	process_config;
}

#############################################################################################



#############################################################################################
# called by set_terminator to create children for terminals

function create_child() { 
      if [ $lastorder -eq 1 ]; then 
	  lastorder=1;
	  lastord=1;
	  ((lastorder--))
      else
	  lastord=0;
	  lastorder=0;
	  ((lastorder++))
      fi  
	lastval=0;
	if  [ $tabtotal -gt 1 ] ; then
	  lastval=$previouschildid2;
	else
	  lastval=$previouschildid1;
	fi
	CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[child$currentid]]]\n   position = $winpos\n   type = $pane\n   order =$lastord\n   parent=child$lastval\n";
	previousid=$currentid;
	((currentid++)) 
	terminal_id=$currentid;
}


#############################################################################################
# called by set_terminator to create children for terminals in bigger window requirements


function create_child2() { 
    if [ $tabtotal -gt 1 ]; then
	CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[child$currentid]]]\n   position = $winpos\n   type= $pane\n   order = $bb\n   parent = child$childbefore\n";
    else
	CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[child$currentid]]]\n   position = $winpos\n   type =$pane\n   order = $bb\n   parent = child$childbefore\n";
    fi
    previousid=$currentid;
    ((currentid++)) 
    terminal_id=$currentid;
}
#############################################################################################


#############################################################################################
# called by set_terminator to create actual terminals per server

function create_terminals() {
	  	for ((ee=0; ee < 1; ee++)) 
		do
		    currserver2=""; currserver1=""; currserver=""; 
		    currgroup2=""; currgroup1=""; currentgroup2="" currentgroup1="";
		    m1=`expr $servercount - $currentserversize`
		    ((currentserversize--))

		    if [ $WINDOWS -ge 2 ]; then
		      m2=`expr $servercount - $currentserversize`
		      ((currentserversize--))
		      
		      currserver=${serverarray[$m2]}
		      if [[ $currserver =~ | ]]; then
			  currserver2=`echo $currserver|awk -F"|" '{print $1}'`
			  currgroup2=`echo $currserver|awk -F"|" '{print $2}'`
		      else
			  currserver2=$currserver
		      fi
		    fi
		    c=0; d=1;
		    command1="";
		    command2="";
		    currserver=${serverarray[$m1]}
		    if [[ $currserver =~ | ]]; then
			  currserver1=`echo $currserver|awk -F"|" '{print $1}'`
			  currgroup1=`echo $currserver|awk -F"|" '{print $2}'`
		    else
			  currserver1=$currserver
		    fi

		    if [ $DEBUG -ge 1 ];then
			echo " ---> $currserver1 $m1"
			echo " ---> $currserver2 $m2"
		    fi
		    if [ "$currserver1" != "" ];then
			if [ $DEBUG -ge 1 ]; then
			  command1="command = /bin/bash\n"
			else
			  command1="command = ssh $currserver1\n"
			fi 
			if [ "$currgroup1" != "" ];then 
			  currentgroup1="group = $currgroup1\n"
			fi
		    fi
		    if [ "$currserver2" != "" ];then
			if [ $DEBUG -ge 1 ]; then
			  command2="command = /bin/bash\n"
			else
			  command2="command = ssh $currserver2\n"
			fi
			if [ "$currgroup2" != "" ];then 
			    currentgroup2="group = $currgroup2\n"
			fi
		    fi
		    CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[terminal$terminal_id]]]\n   profile = default\n   "$command1"\n   "$currentgroup1"   type = Terminal\n   order = $c\n   parent = child$previousid\n";
		    ((terminal_id++))
		    #if  [ "$currserver2" != "" ] && [ $servercount -gt 1 ] &&  [ $currentserversize -ne $servercount ]; then 
		    if [ $servercount -gt 1 ]; then
			CONFIG_LAYOUT=$CONFIG_LAYOUT" [[[terminal$terminal_id]]]\n   profile = default\n   "$command2"\n   "$currentgroup2"   type = Terminal\n   order = $d\n   parent = child$previousid\n";
			((terminal_id++))	
		    fi
		    currentid=$terminal_id;
		  done
}

#############################################################################################



#############################################################################################	      
function usage() { 
  clear;
  colourit red "options: "
  echo -e "-r  | --removelayout   				|  remove layout and refresh it"
  echo -e "-fs | --fullscreen  				|  start session in full screen mode, Override FULL_SCREEN_MODE=0"
  echo -e "-g | --group  				|  groups server as per naming set_apptype, Override AUTO_GROUPING_ENABLED=0"
  echo -e "-w  | --windows  [2/4/8 ]  			| -w followed by 2 or 4 or 8 windows per tab"
  echo -e "-x  | --times  [1-10 ]  			| -x followed by 1 to any number above - reconnect value per server"
  colourit red  "Followed by either:"
  echo -e "-s  | --servers |[s1,s2,s3]			| where s1,s2,s3 is server name seperated by commas"
  echo -e "-f  | --file [./mail.txt]			| where mail.txt contains list of mail servers"
  echo -e "-a  | --autodiscover [val1] [val2] [val3]	| explained in detail below" 
  echo;
  colourit black "Usage: `basename $0`  [-h {for help}]  | [-c {connect to existing layouts} ] |  [-d {delete existing layout} ]" 
  colourit black "Usage: `basename $0`  [-l {for list servers} followed by prod/stage/uat atjmo app1 app2 app3 app4 app5 app6 ]  "
  colourit black "Usage: `basename $0`  [-r  remove layout and recreate ] [-fs {fullscreen mode} ] [-w {windows} 2/4/8] [-f {for file} filename ]";
  colourit black "Usage: `basename $0`  [-r  remove layout and recreate ] [-fs {fullscreen mode} ] [-w {windows} 2/4/8] [-a {for autodiscovery}  prod/stage/uat atjmo app1..app6 ] ";
  colourit black "Usage: `basename $0`  [-r  remove layout and recreate ] [-fs {fullscreen mode} ] [-w {windows} 2/4/8] [-s {server1,server2,server3} ";

  echo;colourit red "Command Line Input CLI  connect example:";
  colourit black "EXAMPLE 1:  `basename $0` -fs -x 2 -w 8 -s server1,server2,server4..server8     {Fullscreen mode, 8 windows per tab connect twice per server to comma seperated list of servers given  = 16 windows 2 tabs } "
  colourit black "EXAMPLE 2:  `basename $0` -r -w 2 -x 3 -s montct01,monapa01  {Remove layout 2 windows per tab X 3 comma seperated list i.e. 3 times to monstct01 and 3 times to monsapa01  2 per tab = 3 tabs } "
  

  echo;colourit red "File connect example:";
  colourit black "EXAMPLE 3:  `basename $0` -w 8 -f  ./servers.txt     {Go through servers.txt and connect to all with 8 windows per tab } "
  colourit black "EXAMPLE 4:  `basename $0` -r -w 8 -f  ./servers.txt  {Remove layout go through file and connect 8 windows per tab} "

  echo
  colourit red "Auto discovery connect examples:";
  colourit blue  "`basename $0` -a {environment} {apptype} {applications}"
  colourit black '{environment} can be: prod/stage/uat'
  colourit black '{apptype} can be: matjo includes msyql/tomcat/apache/jboss/oracle use 1 or all or a combination'
  colourit black '{applications} are seperated by spaces i.e. gw td iw and so forth up to 6 environements accepted'
  
  echo; 
  colourit black "EXAMPLE 5: `basename $0`  -r -w 8 -fs -x 3 -a prod at td    {Remove layout, rediscover and connect to londons(tct/apa)01[a-z]{td|at} 3 times, 8 windows per tab, fullscreen}"
  colourit black "EXAMPLE 6:  `basename $0` -w 8 -a prod gw    {Connect to londons(apa/jbs)01[a-z]gw and try for 8 windows per tab}"
  colourit black "EXAMPLE 7:  `basename $0` -x 2 -a prod at bh gw      {Connect to londons(apa/tct)01[a-z]bh + londons(apa/tct)01[a-z]gw twice per server}"
  echo;colourit red "Auto discovery list example:";
  colourit black "EXAMPLE 8:  `basename $0` -l  prod at sd fg     {List all servers connectable on londons(apa/tct)01[a-z]sd + londons(apa/tct)01[a-z]fg} "
  echo;colourit red "Existing Layout connection:";
  colourit black "EXAMPLE 9:  `basename $0` -c   {List existing layouts and give u numeric option to connect to them} "

  echo;colourit red "Removal of existing layout:";
  colourit black "EXAMPLE 10:  `basename $0` -d   {List existing layouts and give u numeric option to remove 1} "

  
}
#############################################################################################



#############################################################################################
function colourit() {
    type=$1;
    input=$2;
    escape_start="\\033";
    cyan=$escape_start"[0;36m";
    brightyellow=$escape_start"[1;33m"
    brightmagenta=$escape_start"[1;35m"
    brightred=$escape_start"[1;31m"
    brightgreen=$escape_start"[1;32m"
    escape_end="\033[0m"
    bgred=$escape_start"[1;33m"$escape_start"[41m"
    bggreen=$escape_start"[1;33m"$escape_start"[42m"
    bgblue=$escape_start"[1;1m"$escape_start"[44m"
    bgblack=$escape_start"[1;1m"$escape_start"[40m"
    if [ "$type" == "red" ]; then
        out1="$bgred$input$escape_end";
    elif [ "$type" == "green" ]; then
        out1="$bggreen$input$escape_end";
    elif [ "$type" == "blue" ]; then
        out1="$bgblue$input$escape_end";
    elif [ "$type" == "black" ]; then
        out1="$bgblack$input$escape_end";
    fi
  echo  -e $out1
}

#############################################################################################




USERCHOICE=""
REMOVE_LAYOUT=0;
while test -n "$1"; do
    case "$1" in
        --help|-h)
           usage
            exit 0
            ;;
        --windows|-w)
		WINDOWS=$2;
		go="false";
		if   [[ $WINDOWS = 1 ]] || [[ $WINDOWS = 2 ]] || [[ $WINDOWS = 4 ]] || [[ $WINDOWS = 8 ]]; then 
		    go="true";
		else
		    WINDOWS=$DEFAULT_WINDOWS;
		fi
	      
		if [ "$go" == "false" ]; then
		    echo "ERROR - WINDOWS CAN ONLY BE 2, 4 or 8 "
		    exit 1;
		fi
	      
		shift
            ;;

        --fullscreen|-fs)
		FULL_SCREEN_MODE=1;
		#shift
            ;;
        --group|-g)
		AUTO_GROUPING_ENABLED=1;
		#shift
            ;;
        --connect|-c)
		connect_existing_layout
		shift
            ;;
	 --del|-d)
		delete_existing_layout;
		 shift;
	    ;;
	 --removelayout|-r)
		 REMOVE_LAYOUT=1;
		 #shift;
	    ;;
	 --times|-x)
		reconnect=$2;
		shift;
	    ;;
	 --servers|-s)
		USERCHOICE="I"
		servernames=$2
		read_cli_servers;
		set_terminator;
		terminator -l $layout&
		exit 0;
	    ;;
	 --list|-l)
		environment=$2
		apptype=$3
		apparray=( $4 $5 $6 $7 $8 $9 )
		echo "Listing servers for  $environment $apptype"
		set_environment;
		set_apptype;
		if [ "$environment" == "" ] || [ "$apptype" == "" ] ; then
		  usage
		  exit 1;
		fi
		DEBUG=1;
		validate_servers;
		exit 0;
            ;;
        --file|-f)
		USERCHOICE="F"
		FILE=$2
		set_terminator;
		layout=${layout//[[:space:]]}
		terminator -l "$layout"&
		exit 0;
            ;;
        --autodiscover|-a)
		USERCHOICE="A"
		environment=$2
		apptype=$3
		apparray=( $4 $5 $6 $7 $8 $9 )
		set_environment;		    
		set_apptype;
		if [ "$environment" == "" ] || [ "$apptype" == "" ] ;then
		    usage
		    exit
		fi
	#	DEBUG=1;
		validate_servers;
		#check_method;
		set_terminator;
		layout=${layout//[[:space:]]}
		terminator -l "$layout"& 
		exit 0
            ;;
        *)
		echo "Unknown argument: $1"
		 echo "-h for help";
		exit 1
            ;;
    esac
    shift
done

#############################################################################################

#############################################################################################
if [ $# -eq 0 ]; then
   echo "-h for help";
    exit 1;
fi
#############################################################################################

